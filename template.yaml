AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: >
  appsync-authentication

Parameters:
  Region:
    Type: String
    Default: us-west-2
    Description: Region-Name

Resources:
  #ROLE StudentsGQL
  AppsyncAuthenticationDynamoDBRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - appsync.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: dynamodb-access
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource: 
                  - !GetAtt StudentsTable.Arn

  AWSAppSyncPushToCloudWatchLogsRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - appsync.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Policies:
        - PolicyName: appsync-publish-logs
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: 
                  - "*"

  #APPSYNC
  StudentsGQL:
    Type: AWS::AppSync::GraphQLApi
    Properties:
      AuthenticationType: AWS_IAM
      Name: StudentsGQL
      LogConfig:
        CloudWatchLogsRoleArn: !GetAtt AWSAppSyncPushToCloudWatchLogsRole.Arn
        FieldLogLevel: ALL
  
  StudentsAPIDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt StudentsGQL.ApiId
      Name: !Ref StudentsTable
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt AppsyncAuthenticationDynamoDBRole.Arn
      DynamoDBConfig:
        AwsRegion: !Ref Region
        TableName: !Ref StudentsTable

  StudentsAPISchema:
    Type: AWS::AppSync::GraphQLSchema
    Properties: 
      ApiId: !GetAtt StudentsGQL.ApiId
      Definition: |
        type Mutation @aws_iam {
          addStudent(ID: ID!, input: StudentInput): Student
          updateStudent(ID: ID!, input: StudentInput): Student
        }

        type Query @aws_iam {
          getStudent(ID: ID!): Student
          getStudentByEmail(Email: String!): Student
        }

        type Student @aws_iam {
          ID: ID
          __typename: String
          FullName: String
          Active: Boolean
          Age: String
          AgeSchool: String
          Email: String
          CreatedAt: AWSDateTime
          ModifiedAt: AWSDateTime
          Phone: String
        }

        type StudentConnection @aws_iam {
          items: [Student]
          nextToken: String
        }

        input StudentInput @aws_iam {
          FullName: String!
          Active: Boolean!
          Age: String
          AgeSchool: String
          Email: String
          Phone: String
        }

        schema {
          query: Query
          mutation: Mutation
        }

  getStudentResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: StudentsAPISchema
    Properties:
      ApiId: !GetAtt StudentsGQL.ApiId
      TypeName: Query
      FieldName: getStudent
      DataSourceName: !GetAtt StudentsAPIDataSource.Name
      RequestMappingTemplate: >
        {
          "version": "2017-02-28",
          "operation": "GetItem",
          "key": {
            "ID": $util.dynamodb.toDynamoDBJson($ctx.args.ID),
          },
        }
      ResponseMappingTemplate: >
        $util.toJson($context.result)

  updateStudentResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: StudentsAPISchema
    Properties:
      ApiId: !GetAtt StudentsGQL.ApiId
      TypeName: Mutation
      FieldName: updateStudent
      DataSourceName: !GetAtt StudentsAPIDataSource.Name
      RequestMappingTemplate: >
        {
          "version": "2017-02-28",
          "operation": "UpdateItem",
          "key": {
            "ID": $util.dynamodb.toDynamoDBJson($ctx.args.ID),
          },
          ## Set up some space to keep track of things we're updating **
          #set( $expNames  = {} )
          #set( $expValues = {} )
          #set( $expSet = {} )
          #set( $expAdd = {} )
          #set( $expRemove = [] )
          #set( $ModifiedAt = $util.time.nowISO8601() )
          $util.qr( $ctx.args.input.put("ModifiedAt", $ModifiedAt) )
          ## Iterate through each argument, skipping keys **
          #foreach( $entry in $util.map.copyAndRemoveAllKeys($ctx.args.input, ["ID"]).entrySet() )
            #if( $util.isNull($entry.value) )
              ## If the argument is set to "null", then remove that attribute from the item in DynamoDB **
              #set( $discard = ${expRemove.add("#${entry.key}")} )
              $!{expNames.put("#${entry.key}", "${entry.key}")}
            #else
              ## Otherwise set (or update) the attribute on the item in DynamoDB **
              $!{expSet.put("#${entry.key}", ":${entry.key}")}
              $!{expNames.put("#${entry.key}", "${entry.key}")}
              $!{expValues.put(":${entry.key}", $util.dynamodb.toDynamoDB($entry.value))}
            #end
          #end
          ## Start building the update expression, starting with attributes we're going to SET **
          #set( $expression = "" )
          #if( !${expSet.isEmpty()} )
            #set( $expression = "SET" )
            #foreach( $entry in $expSet.entrySet() )
              #set( $expression = "${expression} ${entry.key} = ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end
          ## Continue building the update expression, adding attributes we're going to ADD **
          #if( !${expAdd.isEmpty()} )
            #set( $expression = "${expression} ADD" )
            #foreach( $entry in $expAdd.entrySet() )
              #set( $expression = "${expression} ${entry.key} ${entry.value}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end
          ## Continue building the update expression, adding attributes we're going to REMOVE **
          #if( !${expRemove.isEmpty()} )
            #set( $expression = "${expression} REMOVE" )
            #foreach( $entry in $expRemove )
              #set( $expression = "${expression} ${entry}" )
              #if ( $foreach.hasNext )
                #set( $expression = "${expression}," )
              #end
            #end
          #end
          ## Finally, write the update expression into the document, along with any expressionNames and expressionValues **
          "update": {
            "expression": "${expression}",
            #if( !${expNames.isEmpty()} )
              "expressionNames": $utils.toJson($expNames),
            #end
            #if( !${expValues.isEmpty()} )
              "expressionValues": $utils.toJson($expValues),
            #end
          },
          "condition": {
            "expression": "attribute_exists(#ID)",
            "expressionNames": {
              "#ID": "ID",
            },
          }
        }
      ResponseMappingTemplate: >
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $util.toJson($context.result)
        #end

  addStudentsResolver:
    Type: AWS::AppSync::Resolver
    DependsOn: StudentsAPISchema
    Properties:
      ApiId: !GetAtt StudentsGQL.ApiId
      TypeName: Mutation
      FieldName: addStudent
      DataSourceName: !GetAtt StudentsAPIDataSource.Name
      RequestMappingTemplate: >
        {
          "version" : "2018-05-29",
          "operation" : "PutItem",
          "key" : {
              "ID" : $util.dynamodb.toDynamoDBJson($context.arguments.ID)
          },
          
          #set( $map = $util.defaultIfNull($ctx.args.input, {}) )
          #set( $datetimenow = $util.time.nowISO8601())
          $util.qr($map.put("__typename", "Students"))
          $util.qr($map.put("CreatedAt", $datetimenow))
          $util.qr($map.put("ModifiedAt", $datetimenow))
          "attributeValues" : $util.dynamodb.toMapValuesJson($map),
          "condition" : {
              "expression" : "attribute_not_exists(ID)"
          },
        }

      ResponseMappingTemplate: >
        #if($ctx.error)
          $util.error($ctx.error.message, $ctx.error.type)
        #else
          $util.toJson($context.result)
        #end


  #DYNAMO
  StudentsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: Student
      BillingMode: PAY_PER_REQUEST
      KeySchema:
        - AttributeName: ID
          KeyType: HASH
      AttributeDefinitions:
        - AttributeName: ID
          AttributeType: S
        - AttributeName: Email
          AttributeType: S
        - AttributeName: FullName
          AttributeType: S
      GlobalSecondaryIndexes:
        - IndexName: Email
          KeySchema:
            - AttributeName: Email
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        - IndexName: FullName
          KeySchema:
            - AttributeName: FullName
              KeyType: HASH
          Projection:
            ProjectionType: ALL
        


  #LAMBDA
  AppsyncAuthenticationFunction:
    Type: AWS::Serverless::Function # More info about Function Resource: https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction
    Properties:
      CodeUri: appsync_authentication/
      Handler: app.lambda_handler
      Runtime: python3.9
      Environment:
        Variables:
          ApiUrl: !GetAtt StudentsGQL.GraphQLUrl

Outputs:
  AppsyncAuthenticationARN:
    Description: StudentsGQL Arn
    Value: !GetAtt StudentsGQL.Arn
  Student:
    Description: Student table created with this template
    Value: !GetAtt StudentsTable.Arn